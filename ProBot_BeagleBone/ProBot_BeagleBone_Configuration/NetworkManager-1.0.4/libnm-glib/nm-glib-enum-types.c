


/* Generated by glib-mkenums. Do not edit */

#include "nm-glib-enum-types.h"

#include "nm-object.h" 
#include "nm-client.h" 
#include "nm-device.h" 
#include "nm-device-ethernet.h" 
#include "nm-device-infiniband.h" 
#include "nm-device-adsl.h" 
#include "nm-device-wifi.h" 
#include "nm-device-bt.h" 
#include "nm-device-olpc-mesh.h" 
#include "nm-device-bond.h" 
#include "nm-device-team.h" 
#include "nm-device-bridge.h" 
#include "nm-device-vlan.h" 
#include "nm-device-generic.h" 
#include "nm-access-point.h" 
#include "nm-ip4-config.h" 
#include "nm-device-modem.h" 
#include "nm-vpn-connection.h" 
#include "nm-types.h" 
#include "nm-active-connection.h" 
#include "nm-dhcp4-config.h" 
#include "nm-ip6-config.h" 
#include "nm-dhcp6-config.h" 
#include "nm-remote-connection.h" 
#include "nm-remote-settings.h" 
#include "nm-secret-agent.h" 
#include "nm-device-wimax.h" 
#include "nm-wimax-nsp.h"

GType
nm_object_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_OBJECT_ERROR_UNKNOWN, "NM_OBJECT_ERROR_UNKNOWN", "unknown" },
        { NM_OBJECT_ERROR_OBJECT_CREATION_FAILURE, "NM_OBJECT_ERROR_OBJECT_CREATION_FAILURE", "object-creation-failure" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMObjectError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_client_permission_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_CLIENT_PERMISSION_NONE, "NM_CLIENT_PERMISSION_NONE", "none" },
        { NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK, "NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK", "enable-disable-network" },
        { NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI, "NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI", "enable-disable-wifi" },
        { NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN, "NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN", "enable-disable-wwan" },
        { NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX, "NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX", "enable-disable-wimax" },
        { NM_CLIENT_PERMISSION_SLEEP_WAKE, "NM_CLIENT_PERMISSION_SLEEP_WAKE", "sleep-wake" },
        { NM_CLIENT_PERMISSION_NETWORK_CONTROL, "NM_CLIENT_PERMISSION_NETWORK_CONTROL", "network-control" },
        { NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED, "NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED", "wifi-share-protected" },
        { NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN, "NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN", "wifi-share-open" },
        { NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM, "NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM", "settings-modify-system" },
        { NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN, "NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN", "settings-modify-own" },
        { NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME, "NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME", "settings-modify-hostname" },
        { NM_CLIENT_PERMISSION_LAST, "NM_CLIENT_PERMISSION_LAST", "last" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMClientPermission"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_client_permission_result_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_CLIENT_PERMISSION_RESULT_UNKNOWN, "NM_CLIENT_PERMISSION_RESULT_UNKNOWN", "unknown" },
        { NM_CLIENT_PERMISSION_RESULT_YES, "NM_CLIENT_PERMISSION_RESULT_YES", "yes" },
        { NM_CLIENT_PERMISSION_RESULT_AUTH, "NM_CLIENT_PERMISSION_RESULT_AUTH", "auth" },
        { NM_CLIENT_PERMISSION_RESULT_NO, "NM_CLIENT_PERMISSION_RESULT_NO", "no" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMClientPermissionResult"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_client_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_CLIENT_ERROR_UNKNOWN, "NM_CLIENT_ERROR_UNKNOWN", "UnknownError" },
        { NM_CLIENT_ERROR_MANAGER_NOT_RUNNING, "NM_CLIENT_ERROR_MANAGER_NOT_RUNNING", "ManagerNotRunning" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMClientError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_ERROR_UNKNOWN, "NM_DEVICE_ERROR_UNKNOWN", "UnknownError" },
        { NM_DEVICE_ERROR_INTERFACE_MISMATCH, "NM_DEVICE_ERROR_INTERFACE_MISMATCH", "InterfaceMismatch" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_ethernet_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_ETHERNET_ERROR_UNKNOWN, "NM_DEVICE_ETHERNET_ERROR_UNKNOWN", "UnknownError" },
        { NM_DEVICE_ETHERNET_ERROR_NOT_ETHERNET_CONNECTION, "NM_DEVICE_ETHERNET_ERROR_NOT_ETHERNET_CONNECTION", "NotEthernetConnection" },
        { NM_DEVICE_ETHERNET_ERROR_INVALID_ETHERNET_CONNECTION, "NM_DEVICE_ETHERNET_ERROR_INVALID_ETHERNET_CONNECTION", "InvalidEthernetConnection" },
        { NM_DEVICE_ETHERNET_ERROR_INVALID_DEVICE_MAC, "NM_DEVICE_ETHERNET_ERROR_INVALID_DEVICE_MAC", "InvalidDeviceMac" },
        { NM_DEVICE_ETHERNET_ERROR_MAC_MISMATCH, "NM_DEVICE_ETHERNET_ERROR_MAC_MISMATCH", "MacMismatch" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceEthernetError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_infiniband_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_INFINIBAND_ERROR_UNKNOWN, "NM_DEVICE_INFINIBAND_ERROR_UNKNOWN", "UnknownError" },
        { NM_DEVICE_INFINIBAND_ERROR_NOT_INFINIBAND_CONNECTION, "NM_DEVICE_INFINIBAND_ERROR_NOT_INFINIBAND_CONNECTION", "NotInfinibandConnection" },
        { NM_DEVICE_INFINIBAND_ERROR_INVALID_INFINIBAND_CONNECTION, "NM_DEVICE_INFINIBAND_ERROR_INVALID_INFINIBAND_CONNECTION", "InvalidInfinibandConnection" },
        { NM_DEVICE_INFINIBAND_ERROR_INVALID_DEVICE_MAC, "NM_DEVICE_INFINIBAND_ERROR_INVALID_DEVICE_MAC", "InvalidDeviceMac" },
        { NM_DEVICE_INFINIBAND_ERROR_MAC_MISMATCH, "NM_DEVICE_INFINIBAND_ERROR_MAC_MISMATCH", "MacMismatch" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceInfinibandError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_adsl_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_ADSL_ERROR_UNKNOWN, "NM_DEVICE_ADSL_ERROR_UNKNOWN", "UnknownError" },
        { NM_DEVICE_ADSL_ERROR_NOT_ADSL_CONNECTION, "NM_DEVICE_ADSL_ERROR_NOT_ADSL_CONNECTION", "NotAdslConnection" },
        { NM_DEVICE_ADSL_ERROR_INVALID_ADSL_CONNECTION, "NM_DEVICE_ADSL_ERROR_INVALID_ADSL_CONNECTION", "InvalidAdslConnection" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceAdslError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_wifi_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_WIFI_ERROR_UNKNOWN, "NM_DEVICE_WIFI_ERROR_UNKNOWN", "UnknownError" },
        { NM_DEVICE_WIFI_ERROR_NOT_WIFI_CONNECTION, "NM_DEVICE_WIFI_ERROR_NOT_WIFI_CONNECTION", "NotWifiConnection" },
        { NM_DEVICE_WIFI_ERROR_INVALID_WIFI_CONNECTION, "NM_DEVICE_WIFI_ERROR_INVALID_WIFI_CONNECTION", "InvalidWifiConnection" },
        { NM_DEVICE_WIFI_ERROR_INVALID_DEVICE_MAC, "NM_DEVICE_WIFI_ERROR_INVALID_DEVICE_MAC", "InvalidDeviceMac" },
        { NM_DEVICE_WIFI_ERROR_MAC_MISMATCH, "NM_DEVICE_WIFI_ERROR_MAC_MISMATCH", "MacMismatch" },
        { NM_DEVICE_WIFI_ERROR_MISSING_DEVICE_WPA_CAPS, "NM_DEVICE_WIFI_ERROR_MISSING_DEVICE_WPA_CAPS", "MissingDeviceWpaCaps" },
        { NM_DEVICE_WIFI_ERROR_MISSING_DEVICE_RSN_CAPS, "NM_DEVICE_WIFI_ERROR_MISSING_DEVICE_RSN_CAPS", "MissingDeviceRsnCaps" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceWifiError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_bt_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_BT_ERROR_UNKNOWN, "NM_DEVICE_BT_ERROR_UNKNOWN", "UnknownError" },
        { NM_DEVICE_BT_ERROR_NOT_BT_CONNECTION, "NM_DEVICE_BT_ERROR_NOT_BT_CONNECTION", "NotBtConnection" },
        { NM_DEVICE_BT_ERROR_INVALID_BT_CONNECTION, "NM_DEVICE_BT_ERROR_INVALID_BT_CONNECTION", "InvalidBtConnection" },
        { NM_DEVICE_BT_ERROR_INVALID_DEVICE_MAC, "NM_DEVICE_BT_ERROR_INVALID_DEVICE_MAC", "InvalidDeviceMac" },
        { NM_DEVICE_BT_ERROR_MAC_MISMATCH, "NM_DEVICE_BT_ERROR_MAC_MISMATCH", "MacMismatch" },
        { NM_DEVICE_BT_ERROR_MISSING_DEVICE_CAPS, "NM_DEVICE_BT_ERROR_MISSING_DEVICE_CAPS", "MissingDeviceCaps" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceBtError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_olpc_mesh_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_OLPC_MESH_ERROR_UNKNOWN, "NM_DEVICE_OLPC_MESH_ERROR_UNKNOWN", "UnknownError" },
        { NM_DEVICE_OLPC_MESH_ERROR_NOT_OLPC_MESH_CONNECTION, "NM_DEVICE_OLPC_MESH_ERROR_NOT_OLPC_MESH_CONNECTION", "NotOlpcMeshConnection" },
        { NM_DEVICE_OLPC_MESH_ERROR_INVALID_OLPC_MESH_CONNECTION, "NM_DEVICE_OLPC_MESH_ERROR_INVALID_OLPC_MESH_CONNECTION", "InvalidOlpcMeshConnection" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceOlpcMeshError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_bond_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_BOND_ERROR_UNKNOWN, "NM_DEVICE_BOND_ERROR_UNKNOWN", "UnknownError" },
        { NM_DEVICE_BOND_ERROR_NOT_BOND_CONNECTION, "NM_DEVICE_BOND_ERROR_NOT_BOND_CONNECTION", "NotBondConnection" },
        { NM_DEVICE_BOND_ERROR_INVALID_BOND_CONNECTION, "NM_DEVICE_BOND_ERROR_INVALID_BOND_CONNECTION", "InvalidBondConnection" },
        { NM_DEVICE_BOND_ERROR_INTERFACE_MISMATCH, "NM_DEVICE_BOND_ERROR_INTERFACE_MISMATCH", "InterfaceMismatch" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceBondError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_team_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_TEAM_ERROR_UNKNOWN, "NM_DEVICE_TEAM_ERROR_UNKNOWN", "UnknownError" },
        { NM_DEVICE_TEAM_ERROR_NOT_TEAM_CONNECTION, "NM_DEVICE_TEAM_ERROR_NOT_TEAM_CONNECTION", "NotTeamConnection" },
        { NM_DEVICE_TEAM_ERROR_INVALID_TEAM_CONNECTION, "NM_DEVICE_TEAM_ERROR_INVALID_TEAM_CONNECTION", "InvalidTeamConnection" },
        { NM_DEVICE_TEAM_ERROR_INTERFACE_MISMATCH, "NM_DEVICE_TEAM_ERROR_INTERFACE_MISMATCH", "InterfaceMismatch" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceTeamError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_bridge_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_BRIDGE_ERROR_UNKNOWN, "NM_DEVICE_BRIDGE_ERROR_UNKNOWN", "UnknownError" },
        { NM_DEVICE_BRIDGE_ERROR_NOT_BRIDGE_CONNECTION, "NM_DEVICE_BRIDGE_ERROR_NOT_BRIDGE_CONNECTION", "NotBridgeConnection" },
        { NM_DEVICE_BRIDGE_ERROR_INVALID_BRIDGE_CONNECTION, "NM_DEVICE_BRIDGE_ERROR_INVALID_BRIDGE_CONNECTION", "InvalidBridgeConnection" },
        { NM_DEVICE_BRIDGE_ERROR_INTERFACE_MISMATCH, "NM_DEVICE_BRIDGE_ERROR_INTERFACE_MISMATCH", "InterfaceMismatch" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceBridgeError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_vlan_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_VLAN_ERROR_UNKNOWN, "NM_DEVICE_VLAN_ERROR_UNKNOWN", "UnknownError" },
        { NM_DEVICE_VLAN_ERROR_NOT_VLAN_CONNECTION, "NM_DEVICE_VLAN_ERROR_NOT_VLAN_CONNECTION", "NotVlanConnection" },
        { NM_DEVICE_VLAN_ERROR_INVALID_VLAN_CONNECTION, "NM_DEVICE_VLAN_ERROR_INVALID_VLAN_CONNECTION", "InvalidVlanConnection" },
        { NM_DEVICE_VLAN_ERROR_ID_MISMATCH, "NM_DEVICE_VLAN_ERROR_ID_MISMATCH", "IdMismatch" },
        { NM_DEVICE_VLAN_ERROR_INTERFACE_MISMATCH, "NM_DEVICE_VLAN_ERROR_INTERFACE_MISMATCH", "InterfaceMismatch" },
        { NM_DEVICE_VLAN_ERROR_MAC_MISMATCH, "NM_DEVICE_VLAN_ERROR_MAC_MISMATCH", "MacMismatch" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceVlanError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_generic_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_GENERIC_ERROR_UNKNOWN, "NM_DEVICE_GENERIC_ERROR_UNKNOWN", "UnknownError" },
        { NM_DEVICE_GENERIC_ERROR_NOT_GENERIC_CONNECTION, "NM_DEVICE_GENERIC_ERROR_NOT_GENERIC_CONNECTION", "NotGenericConnection" },
        { NM_DEVICE_GENERIC_ERROR_MISSING_INTERFACE_NAME, "NM_DEVICE_GENERIC_ERROR_MISSING_INTERFACE_NAME", "MissingInterfaceName" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceGenericError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_modem_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_MODEM_ERROR_UNKNOWN, "NM_DEVICE_MODEM_ERROR_UNKNOWN", "UnknownError" },
        { NM_DEVICE_MODEM_ERROR_NOT_MODEM_CONNECTION, "NM_DEVICE_MODEM_ERROR_NOT_MODEM_CONNECTION", "NotModemConnection" },
        { NM_DEVICE_MODEM_ERROR_INVALID_MODEM_CONNECTION, "NM_DEVICE_MODEM_ERROR_INVALID_MODEM_CONNECTION", "InvalidModemConnection" },
        { NM_DEVICE_MODEM_ERROR_MISSING_DEVICE_CAPS, "NM_DEVICE_MODEM_ERROR_MISSING_DEVICE_CAPS", "MissingDeviceCaps" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceModemError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_remote_connection_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_REMOTE_CONNECTION_ERROR_UNKNOWN, "NM_REMOTE_CONNECTION_ERROR_UNKNOWN", "UnknownError" },
        { NM_REMOTE_CONNECTION_ERROR_DISCONNECTED, "NM_REMOTE_CONNECTION_ERROR_DISCONNECTED", "Disconnected" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMRemoteConnectionError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_remote_settings_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_REMOTE_SETTINGS_ERROR_UNKNOWN, "NM_REMOTE_SETTINGS_ERROR_UNKNOWN", "UnknownError" },
        { NM_REMOTE_SETTINGS_ERROR_CONNECTION_REMOVED, "NM_REMOTE_SETTINGS_ERROR_CONNECTION_REMOVED", "ConnectionRemoved" },
        { NM_REMOTE_SETTINGS_ERROR_CONNECTION_UNAVAILABLE, "NM_REMOTE_SETTINGS_ERROR_CONNECTION_UNAVAILABLE", "ConnectionUnavailable" },
        { NM_REMOTE_SETTINGS_ERROR_SERVICE_UNAVAILABLE, "NM_REMOTE_SETTINGS_ERROR_SERVICE_UNAVAILABLE", "ServiceUnavailable" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMRemoteSettingsError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_secret_agent_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_SECRET_AGENT_ERROR_NOT_AUTHORIZED, "NM_SECRET_AGENT_ERROR_NOT_AUTHORIZED", "NotAuthorized" },
        { NM_SECRET_AGENT_ERROR_INVALID_CONNECTION, "NM_SECRET_AGENT_ERROR_INVALID_CONNECTION", "InvalidConnection" },
        { NM_SECRET_AGENT_ERROR_USER_CANCELED, "NM_SECRET_AGENT_ERROR_USER_CANCELED", "UserCanceled" },
        { NM_SECRET_AGENT_ERROR_AGENT_CANCELED, "NM_SECRET_AGENT_ERROR_AGENT_CANCELED", "AgentCanceled" },
        { NM_SECRET_AGENT_ERROR_INTERNAL_ERROR, "NM_SECRET_AGENT_ERROR_INTERNAL_ERROR", "InternalError" },
        { NM_SECRET_AGENT_ERROR_NO_SECRETS, "NM_SECRET_AGENT_ERROR_NO_SECRETS", "NoSecrets" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMSecretAgentError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_secret_agent_capabilities_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_SECRET_AGENT_CAPABILITY_NONE, "NM_SECRET_AGENT_CAPABILITY_NONE", "none" },
        { NM_SECRET_AGENT_CAPABILITY_VPN_HINTS, "NM_SECRET_AGENT_CAPABILITY_VPN_HINTS", "vpn-hints" },
        { NM_SECRET_AGENT_CAPABILITY_LAST, "NM_SECRET_AGENT_CAPABILITY_LAST", "last" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NMSecretAgentCapabilities"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_secret_agent_get_secrets_flags_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GFlagsValue values[] = {
        { NM_SECRET_AGENT_GET_SECRETS_FLAG_NONE, "NM_SECRET_AGENT_GET_SECRETS_FLAG_NONE", "none" },
        { NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION, "NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION", "allow-interaction" },
        { NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW, "NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW", "request-new" },
        { NM_SECRET_AGENT_GET_SECRETS_FLAG_USER_REQUESTED, "NM_SECRET_AGENT_GET_SECRETS_FLAG_USER_REQUESTED", "user-requested" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_flags_register_static (g_intern_static_string ("NMSecretAgentGetSecretsFlags"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_device_wimax_error_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_DEVICE_WIMAX_ERROR_UNKNOWN, "NM_DEVICE_WIMAX_ERROR_UNKNOWN", "UnknownError" },
        { NM_DEVICE_WIMAX_ERROR_NOT_WIMAX_CONNECTION, "NM_DEVICE_WIMAX_ERROR_NOT_WIMAX_CONNECTION", "NotWimaxConnection" },
        { NM_DEVICE_WIMAX_ERROR_INVALID_WIMAX_CONNECTION, "NM_DEVICE_WIMAX_ERROR_INVALID_WIMAX_CONNECTION", "InvalidWimaxConnection" },
        { NM_DEVICE_WIMAX_ERROR_INVALID_DEVICE_MAC, "NM_DEVICE_WIMAX_ERROR_INVALID_DEVICE_MAC", "InvalidDeviceMac" },
        { NM_DEVICE_WIMAX_ERROR_MAC_MISMATCH, "NM_DEVICE_WIMAX_ERROR_MAC_MISMATCH", "MacMismatch" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMDeviceWimaxError"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}
GType
nm_wimax_nsp_network_type_get_type (void)
{
  static volatile gsize g_define_type_id__volatile = 0;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const GEnumValue values[] = {
        { NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN, "NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN", "unknown" },
        { NM_WIMAX_NSP_NETWORK_TYPE_HOME, "NM_WIMAX_NSP_NETWORK_TYPE_HOME", "home" },
        { NM_WIMAX_NSP_NETWORK_TYPE_PARTNER, "NM_WIMAX_NSP_NETWORK_TYPE_PARTNER", "partner" },
        { NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER, "NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER", "roaming-partner" },
        { 0, NULL, NULL }
      };
      GType g_define_type_id =
        g_enum_register_static (g_intern_static_string ("NMWimaxNspNetworkType"), values);
      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

  return g_define_type_id__volatile;
}



